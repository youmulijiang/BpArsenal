# 设计模式实现规范

## 模式应用场景

### 1. 工厂模式 (Factory Pattern)
**位置**: `src/main/java/com/yourcompany/burp/patterns/factory/`
**用途**: 创建不同类型的扫描器、处理器、UI组件

```java
/**
 * 扫描器工厂接口
 */
public interface ScannerFactory {
    Scanner createScanner(ScannerType type);
}

/**
 * 具体工厂实现
 */
public class BurpScannerFactory implements ScannerFactory {
    private final MontoyaApi api;
    
    public BurpScannerFactory(MontoyaApi api) {
        this.api = api;
    }
    
    @Override
    public Scanner createScanner(ScannerType type) {
        return switch (type) {
            case SQL_INJECTION -> new SqlInjectionScanner(api);
            case XSS -> new XssScanner(api);
            case DIRECTORY_TRAVERSAL -> new DirectoryTraversalScanner(api);
            default -> throw new IllegalArgumentException("Unsupported scanner type: " + type);
        };
    }
}

/**
 * 扫描器类型枚举
 */
public enum ScannerType {
    SQL_INJECTION,
    XSS,
    DIRECTORY_TRAVERSAL,
    COMMAND_INJECTION,
    FILE_INCLUSION
}
```

### 2. 观察者模式 (Observer Pattern)
**位置**: `src/main/java/com/yourcompany/burp/patterns/observer/`
**用途**: 扫描结果通知、UI状态更新、事件传播

```java
/**
 * 扫描事件观察者接口
 */
public interface ScanEventObserver {
    void onScanStarted(ScanEvent event);
    void onScanProgress(ScanEvent event);
    void onScanCompleted(ScanEvent event);
    void onVulnerabilityFound(VulnerabilityEvent event);
}

/**
 * 扫描事件主题
 */
public class ScanEventSubject {
    private final List<ScanEventObserver> observers = new CopyOnWriteArrayList<>();
    
    public void addObserver(ScanEventObserver observer) {
        observers.add(observer);
    }
    
    public void removeObserver(ScanEventObserver observer) {
        observers.remove(observer);
    }
    
    protected void notifyVulnerabilityFound(VulnerabilityEvent event) {
        observers.forEach(observer -> observer.onVulnerabilityFound(event));
    }
    
    protected void notifyScanCompleted(ScanEvent event) {
        observers.forEach(observer -> observer.onScanCompleted(event));
    }
}

/**
 * UI更新观察者
 */
public class UIUpdateObserver implements ScanEventObserver {
    private final ScanResultPanel resultPanel;
    
    public UIUpdateObserver(ScanResultPanel resultPanel) {
        this.resultPanel = resultPanel;
    }
    
    @Override
    public void onVulnerabilityFound(VulnerabilityEvent event) {
        SwingUtilities.invokeLater(() -> {
            resultPanel.addVulnerability(event.getVulnerability());
        });
    }
    
    @Override
    public void onScanCompleted(ScanEvent event) {
        SwingUtilities.invokeLater(() -> {
            resultPanel.updateScanStatus("扫描完成");
        });
    }
}
```

### 3. 策略模式 (Strategy Pattern)
**位置**: `src/main/java/com/yourcompany/burp/patterns/strategy/`
**用途**: 不同的攻击策略、编码策略、输出格式策略

```java
/**
 * 攻击策略接口
 */
public interface AttackStrategy {
    List<String> generatePayloads(HttpRequest baseRequest);
    boolean isVulnerable(HttpResponse response);
    String getStrategyName();
}

/**
 * SQL注入攻击策略
 */
public class SqlInjectionStrategy implements AttackStrategy {
    
    @Override
    public List<String> generatePayloads(HttpRequest baseRequest) {
        return List.of(
            "' OR 1=1 --",
            "'; DROP TABLE users; --",
            "1' UNION SELECT null,version() --",
            "admin'/*",
            "1' AND SLEEP(5) --"
        );
    }
    
    @Override
    public boolean isVulnerable(HttpResponse response) {
        String body = response.bodyToString().toLowerCase();
        return body.contains("sql") && body.contains("error") ||
               body.contains("mysql") ||
               body.contains("oracle") ||
               body.contains("postgresql");
    }
    
    @Override
    public String getStrategyName() {
        return "SQL注入检测";
    }
}

/**
 * 攻击执行器
 */
public class AttackExecutor {
    private AttackStrategy strategy;
    private final MontoyaApi api;
    
    public AttackExecutor(MontoyaApi api) {
        this.api = api;
    }
    
    public void setStrategy(AttackStrategy strategy) {
        this.strategy = strategy;
    }
    
    public AttackResult executeAttack(HttpRequest baseRequest) {
        if (strategy == null) {
            throw new IllegalStateException("Attack strategy not set");
        }
        
        List<String> payloads = strategy.generatePayloads(baseRequest);
        List<VulnerabilityResult> vulnerabilities = new ArrayList<>();
        
        for (String payload : payloads) {
            HttpRequest testRequest = injectPayload(baseRequest, payload);
            HttpResponse response = api.http().sendRequest(testRequest).response();
            
            if (strategy.isVulnerable(response)) {
                vulnerabilities.add(new VulnerabilityResult(
                    strategy.getStrategyName(),
                    payload,
                    testRequest,
                    response
                ));
            }
        }
        
        return new AttackResult(strategy.getStrategyName(), vulnerabilities);
    }
}
```

### 4. 命令模式 (Command Pattern)
**位置**: `src/main/java/com/yourcompany/burp/patterns/command/`
**用途**: 扫描任务、UI操作、批处理任务

```java
/**
 * 命令接口
 */
public interface Command {
    void execute();
    void undo();
    String getDescription();
}

/**
 * 扫描命令
 */
public class ScanCommand implements Command {
    private final Scanner scanner;
    private final HttpRequest target;
    private final ScanResultRepository repository;
    private ScanResult lastResult;
    
    public ScanCommand(Scanner scanner, HttpRequest target, ScanResultRepository repository) {
        this.scanner = scanner;
        this.target = target;
        this.repository = repository;
    }
    
    @Override
    public void execute() {
        lastResult = scanner.scan(target);
        repository.save(lastResult);
    }
    
    @Override
    public void undo() {
        if (lastResult != null) {
            repository.delete(lastResult.getId());
        }
    }
    
    @Override
    public String getDescription() {
        return "扫描: " + target.url();
    }
}

/**
 * 命令执行器
 */
public class CommandExecutor {
    private final Stack<Command> executedCommands = new Stack<>();
    
    public void execute(Command command) {
        command.execute();
        executedCommands.push(command);
    }
    
    public void undo() {
        if (!executedCommands.isEmpty()) {
            Command lastCommand = executedCommands.pop();
            lastCommand.undo();
        }
    }
    
    public void executeAll(List<Command> commands) {
        commands.forEach(this::execute);
    }
}
```

### 5. 代理模式 (Proxy Pattern)
**位置**: `src/main/java/com/yourcompany/burp/patterns/proxy/`
**用途**: HTTP请求拦截、缓存、日志记录

```java
/**
 * HTTP服务接口
 */
public interface HttpService {
    HttpResponse sendRequest(HttpRequest request);
}

/**
 * 实际HTTP服务
 */
public class BurpHttpService implements HttpService {
    private final MontoyaApi api;
    
    public BurpHttpService(MontoyaApi api) {
        this.api = api;
    }
    
    @Override
    public HttpResponse sendRequest(HttpRequest request) {
        return api.http().sendRequest(request).response();
    }
}

/**
 * HTTP服务代理
 */
public class HttpServiceProxy implements HttpService {
    private final HttpService realService;
    private final Map<String, HttpResponse> cache = new ConcurrentHashMap<>();
    private final MontoyaApi api;
    
    public HttpServiceProxy(HttpService realService, MontoyaApi api) {
        this.realService = realService;
        this.api = api;
    }
    
    @Override
    public HttpResponse sendRequest(HttpRequest request) {
        String cacheKey = generateCacheKey(request);
        
        // 检查缓存
        if (cache.containsKey(cacheKey)) {
            api.logging().logToOutput("缓存命中: " + request.url());
            return cache.get(cacheKey);
        }
        
        // 记录请求日志
        api.logging().logToOutput("发送请求: " + request.method() + " " + request.url());
        
        // 执行实际请求
        HttpResponse response = realService.sendRequest(request);
        
        // 缓存响应
        cache.put(cacheKey, response);
        
        // 记录响应日志
        api.logging().logToOutput("收到响应: " + response.statusCode());
        
        return response;
    }
    
    private String generateCacheKey(HttpRequest request) {
        return request.method() + ":" + request.url() + ":" + 
               request.bodyToString().hashCode();
    }
}
```

### 6. 单例模式 (Singleton Pattern)
**位置**: `src/main/java/com/yourcompany/burp/patterns/singleton/`
**用途**: 配置管理、日志管理、扩展上下文

```java
/**
 * 扩展上下文单例
 */
public class ExtensionContext {
    private static volatile ExtensionContext instance;
    private final MontoyaApi api;
    private final ConfigurationManager configManager;
    private final CommandExecutor commandExecutor;
    
    private ExtensionContext(MontoyaApi api) {
        this.api = api;
        this.configManager = new ConfigurationManager(api);
        this.commandExecutor = new CommandExecutor();
    }
    
    public static ExtensionContext getInstance(MontoyaApi api) {
        if (instance == null) {
            synchronized (ExtensionContext.class) {
                if (instance == null) {
                    instance = new ExtensionContext(api);
                }
            }
        }
        return instance;
    }
    
    public static ExtensionContext getInstance() {
        if (instance == null) {
            throw new IllegalStateException("ExtensionContext not initialized");
        }
        return instance;
    }
    
    public MontoyaApi getApi() { return api; }
    public ConfigurationManager getConfigManager() { return configManager; }
    public CommandExecutor getCommandExecutor() { return commandExecutor; }
}

/**
 * 日志管理器单例
 */
public class LogManager {
    private static volatile LogManager instance;
    private final MontoyaApi api;
    private final boolean debugMode;
    
    private LogManager(MontoyaApi api) {
        this.api = api;
        this.debugMode = Boolean.parseBoolean(
            System.getProperty("burp.debug", "false")
        );
    }
    
    public static LogManager getInstance(MontoyaApi api) {
        if (instance == null) {
            synchronized (LogManager.class) {
                if (instance == null) {
                    instance = new LogManager(api);
                }
            }
        }
        return instance;
    }
    
    public static LogManager getInstance() {
        return instance;
    }
    
    public void info(String message) {
        api.logging().logToOutput("[INFO] " + message);
    }
    
    public void error(String message) {
        api.logging().logToError("[ERROR] " + message);
    }
    
    public void debug(String message) {
        if (debugMode) {
            api.logging().logToOutput("[DEBUG] " + message);
        }
    }
}
```

## 模式组合使用示例

### 综合扫描系统
```java
public class VulnerabilityScanner {
    private final ScannerFactory scannerFactory;
    private final ScanEventSubject eventSubject;
    private final CommandExecutor commandExecutor;
    private final HttpService httpService;
    
    public VulnerabilityScanner(MontoyaApi api) {
        this.scannerFactory = new BurpScannerFactory(api);
        this.eventSubject = new ScanEventSubject();
        this.commandExecutor = new CommandExecutor();
        this.httpService = new HttpServiceProxy(new BurpHttpService(api), api);
        
        // 注册UI更新观察者
        eventSubject.addObserver(new UIUpdateObserver(getResultPanel()));
    }
    
    public void scanWithStrategy(HttpRequest target, AttackStrategy strategy) {
        // 使用工厂创建扫描器
        Scanner scanner = scannerFactory.createScanner(ScannerType.SQL_INJECTION);
        
        // 使用命令模式执行扫描
        Command scanCommand = new ScanCommand(scanner, target, getRepository());
        commandExecutor.execute(scanCommand);
        
        // 使用策略模式执行攻击
        AttackExecutor executor = new AttackExecutor(ExtensionContext.getInstance().getApi());
        executor.setStrategy(strategy);
        AttackResult result = executor.executeAttack(target);
        
        // 通知观察者
        eventSubject.notifyVulnerabilityFound(new VulnerabilityEvent(result));
    }
}
```

## 设计模式最佳实践

### 1. 模式选择原则
- **工厂模式**: 需要创建多种相似对象时
- **观察者模式**: 需要解耦事件发布和订阅时
- **策略模式**: 需要在运行时切换算法时
- **命令模式**: 需要撤销操作或批处理时
- **代理模式**: 需要控制对象访问时
- **单例模式**: 需要全局唯一实例时

### 2. 实现注意事项
- 确保线程安全
- 避免过度设计
- 保持接口简洁
- 使用依赖注入
- 编写完整的JavaDoc

### 3. Git提交规范
每次实现新的设计模式后执行：
```bash
git add .
git commit -m "feat: 实现[模式名称]设计模式用于[具体用途]"
```

例如：
```bash
git add .
git commit -m "feat: 实现工厂模式用于扫描器创建"
```
description:
globs:
alwaysApply: false
---
